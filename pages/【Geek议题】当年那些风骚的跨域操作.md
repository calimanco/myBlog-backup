## 前言

现在cross-origin resource sharing（跨域资源共享，下简称CORS）已经十分普及，算上IE8的不标准兼容（XDomainRequest），各大浏览器基本都已支持，当年为了前后端分离、iframe交互和第三方插件开发而头疼跨域是时代已经过去，但当年为了跨域无所不用其极的风骚操作却依然值得学习。  
本篇文章不是从实用的角度考量这些旧时代的跨域手段，而是更偏向理论的阐述，并引发都浏览器安全的思考，因为跨域实际上也是各类攻击的核心。  

## 同源策略

1995年，同源政策由Netscape公司引入浏览器。目前，所有浏览器都实行这个安全策略。  
核心是确保不同源提供的文件（资源）之间是相互独立的。换句话说，只有当不同的文件脚本是由相同的域、端口、HTTP协议提供时，才没有特殊的限制。特殊限制可以细分为两个方面：  

-   对象访问限制：主要体现在iframe，如果父子页面的源是不同的，那就不可以访问对方的DOM方法和属性（包括Cookie、LocalStorage和IndexDB等）。不同来源便抛出异常。  
-   网络访问限制：主要体现在AJAX请求，如果发起的请求目标源与当前页面不同，浏览器就会限制了发起跨站请求，或拦截返回的请求。  

**一个表格看懂什么是同源？**

| origin(URL)               | result  | reason         |
| ------------------------- | ------- | -------------- |
| `http://example.com`      | success | 协议，域名和端口号80均相同 |
| `http://example.com:8080` | fail    | 端口不同           |
| `https://example.com`     | fail    | 协议不同           |
| `http://sub.example.com`  | fail    | 域名不同           |

**至于为什么说这是个安全策略？**  
这个就要提到cookie-session机制，众所周知HTTP是无状态协议，而服务器如何知晓用户的登录状态？传统上是使用了cookie-session这一机制，也就是服务器为每个访问者生成了一个session标识，而session标识会被服务器包含在应答头中返回，浏览器解析到应答头中的set-cookie就把这串session标识保存到本地cookie中，利用cookie每次请求同一个域都会带上的特性，服务器器就能知晓当前的用户登录状态。  
所以如果让浏览器向不同源发起请求，就会造成很大的危险。比如用户登录了银行的网站A，也就是说A站已经在浏览器留下了cookie，这时候用户又访问了B站，如果能在B站页面上发起A站的请求，就相当于B站可以冒充用户，在A站为所欲为。  
由此可见，"同源政策"是必需的，否则cookie可以共享，互联网就毫无安全可言了。  

## 跨域方案

同源策略提出的时代还是传统MVC架构（jsp，asp）盛行的年代，那时候的页面靠服务器渲染完成了大部分填充，内容也比较简单，开发者也不会维护独立的API工程，所以其实跨域的需求是比较少的。  
新时代前后端的分离和第三方JSSDK的兴起，我们才开始发现这个策略虽然大大提高了浏览器的安全性，但有时很不方便，合理的用途也受到影响。比如：

1.  独立的API工程部署为了方便管理使用了独立的域名；
2.  前端开发者本地调试需要使用远程的API；
3.  第三方开发的JSSDK需要嵌入到别人的页面中使用；
4.  公共平台的开放API。

于是乎，在没有标准规范的时代，如何解决这些问题的跨域方案就被纷纷提出，可谓百家争鸣，其中不乏令人惊叹的骚操作，这样的极客精神依然值得我们敬佩和学习。  

### JSON-P

JSON-P是各类跨域方案中流行度较高的一个，现在在某些要兼容旧浏览器的环境下还会被使用，著名的jquery也封装其方法。请勿见名知义，名字中的P是padding“带填充”的意思，这个方法在通信过程中使用的并不是普通的json，而是**自带填充功能的JavaScript脚本**。  
如何理解“自带填充功能的JavaScript脚本”，看看下面的例子或许比较简单，如果一个js文件里这样写并被引入，则全局下就会有data对象，也就是说**利用js脚本的引入和解析可以用来传递数据**，如果把js脚本换成函数运行命令岂不是可以调用全局函数了。这就是JSON-P方法的核心思想，它填充的是全局函数的数据。  

```javascript
var data = {
  a: 1,
  b: 2
}
```

> 【PS】`<script>`标签不受同源策略限制。

JSON-P原理及流程：

1.  先定义好回调函数，也就是引入的js脚本中要调用的函数；
2.  新建`<script>`标签，将标签插入页面浏览器便会发起get请求；
3.  服务器根据请求返回js脚本，其中就是调用了回调函数。

```javascript
// 定义回调函数
function getTheAnimal(data){
	var myAnimal = data.animal;
}
// 新建标签
var script = document.createElement("script");
script.type = "text/javascript";
// 常用的在url参数部分跟服务器约定号回调函数名
script.src = "http://demo.com/animal.json?callback=getTheAnimal";
document.getElementByTagName('head')[0].appendChild(script);
```

![jsonp流程图][1]

到这里你可能会有以为，标签岂不只能是get请求？这就是JSON-P的缺点，无法发起除get之外的请求，限制于url的格式，数据量也不可能超过2083字符的限制。  
其实这个方法就是兼容性好这一优点，缺点倒是蛮多的（只列举一些）：  

-   只能是GET方法；
-   受浏览器URL最大长度2083限制；
-   无法调试，服务器错误无法检测到具体原因；
-   有安全风险，CSRF的基础；
-   只能是异步，无法同步阻塞；
-   需要特殊接口支持，很难用于基于REST的API。

### 子域名代理

这个方法实际上是利用浏览器允许iframe内的页面只要是跟父页面是同个一级域名下，就能被父页面修改和调用的特点。也许你会疑问，上面讲同源策略的表格中很明确二级域名不同也是算不同源，这岂不矛盾了？  
这其实不矛盾，如果正常操作确实会被同源策略限制，但浏览器的`document.domain`允许网站将主机部分更改为原始值的后缀。这意味着，寄放在sub.example.com的页面可以将它的源设置为example.com，但是并不能将其设置为alt.example.com或google.com。  
